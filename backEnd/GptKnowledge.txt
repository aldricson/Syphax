frontEnd : Root directory of the frontEnd project, containing all frontend-related files and subdirectories.
frontEnd/SyphaxFrontEnd : Main directory for the Syphax frontend application, containing source code and configuration files.
frontEnd/SyphaxFrontEnd/vite.config.js

// role: Configuration file for Vite, setting up the build and development environment for the Syphax frontend application.

import { defineConfig } from 'vite'; // Import defineConfig function from Vite for creating configuration objects
import reactSupport from '@vitejs/plugin-react'; // Import the React plugin for Vite to enable React support

/**
 * Vite configuration.
 * 
 * This configuration file sets up the Vite build tool for the Syphax frontend application.
 * It includes support for React, Babel parser options for decorators and class properties, and specifies the development server port.
 * 
 * @module vite.config
 */
export default defineConfig({
  plugins: [
    reactSupport({
      babel: {
        parserOpts: {
          plugins: ['decorators-legacy', 'classProperties'] // Enable legacy decorators and class properties support in Babel
        }
      }
    })
  ],
  server: {
    port: 5173 // Set the development server to run on port 5173
  }
});


frontEnd/SyphaxFrontEnd/src : Source directory for the Syphax frontend application, containing React components, stores, and styles.
frontEnd/SyphaxFrontEnd/src/App.jsx

// role: Main application component that handles the conditional rendering of the SignInForm or DashBoard based on login status.

// Import the global stylesheet for the application
import './App.css';
// Import the SignInForm component
import SignInForm from './Components/SignInForm/SignInForm.jsx';
// Import the DashBoard component
import ProtectedDashBoard from './Components/DashBoard/ProtectedDashBoard.jsx';
// Import the authentication store from MobX
import authStore from './mobxStores/authStore';
// Import observer from MobX for observing state changes
import { observer } from 'mobx-react';
// Import the WebSocket instance
import socket from './webSockets/websocket.jsx';

/**
 * App component.
 * 
 * This functional component is the main application component.
 * It observes the authStore to conditionally render either the SignInForm or the DashBoard based on the login status.
 * 
 * @returns {JSX.Element} The rendered application component.
 */
const App = observer(() => {
  // Connect to the WebSocket server
  socket.connect();

  return (
    <div>
      {authStore.token || authStore.user ? (
        // If token and user are available, render the DashBoard component
        <ProtectedDashBoard />
      ) : (
        // If token and user are not available, render the SignInForm component
        <SignInForm />
      )}
    </div>
  );
});

// Export the App component as the default export
export default App;


frontEnd/SyphaxFrontEnd/src/main.jsx

// role: Entry point for the React application, responsible for rendering the main App component.

/**
 * Import React library for building user interfaces.
 * @module React
 */
import React from 'react';

/**
 * Import ReactDOM for rendering React components into the DOM.
 * @module ReactDOM
 */
import ReactDOM from 'react-dom/client';

/**
 * Import the main App component.
 * @module App
 */
import App from './App.jsx';

/**
 * Import the global stylesheet for the application.
 * @module styles
 */
import './index.css';

/**
 * Import the authentication store to initialize the authentication check.
 * @module authStore
 */
import authStore from './mobxStores/authStore';

authStore.checkAuth(); // Check authentication status on page load

/**
 * Render the React application into the DOM.
 * 
 * This method creates a root DOM node, attaches the React application to it,
 * and renders the main App component inside a strict mode environment.
 */
ReactDOM.createRoot(document.getElementById('root')).render(
  // React.StrictMode is a wrapper component that helps with identifying potential problems in the application.
  <React.StrictMode>
    {/* Render the main App component */}
    <App />
  </React.StrictMode>,
);


frontEnd/SyphaxFrontEnd/src/index.css
frontEnd/SyphaxFrontEnd/src/App.css
frontEnd/SyphaxFrontEnd/src/assets : Main directory assets (images, video, sounds, stylesheets)
frontEnd/SyphaxFrontEnd/src/assets/Images : Directory containing image assets for the frontend application.
frontEnd/SyphaxFrontEnd/src/assets/styleSheets : Contains stylesheets
frontEnd/SyphaxFrontEnd/src/assets/styleSheets/signInHeader.css
frontEnd/SyphaxFrontEnd/src/assets/styleSheets/signInForm.css
frontEnd/SyphaxFrontEnd/src/assets/styleSheets/simpleLed.css
frontEnd/SyphaxFrontEnd/src/Components : Contains all the React components used in the Syphax frontend application.
frontEnd/SyphaxFrontEnd/src/Components/Leds and Switches : Contains components all the visual leds or switches components
frontEnd/SyphaxFrontEnd/src/Components/Leds and Switches/SimpleLed.jsx

// role: Provides a simple LED component that changes color based on its state, including a blink functionality.

// Import the observer function from MobX to create an observer component
import { observer } from 'mobx-react';
// Import the MobX store for the SimpleLed component
import newDataLedStore from '../../mobxStores/simpleLedStore.jsx';
// Import the stylesheet for the SimpleLed component
import '../../assets/styleSheets/simpleLed.css';

/**
 * Led component.
 * 
 * This functional component renders an LED with customizable on and off colors.
 * It observes the state from the ledStore to manage the on/off status and colors.
 * 
 * @returns {JSX.Element} The rendered LED component.
 */
const SimpleLed = observer(() => {
  // Define the style for the LED, which changes based on its on/off state
  const ledStyle = {
    backgroundColor: newDataLedStore.isOn ? newDataLedStore.onColor : newDataLedStore.offColor, // Set the background color based on the LED state
    boxShadow: newDataLedStore.isOn 
      ? `0 0 10px ${newDataLedStore.onColor}, 0 0 20px ${newDataLedStore.onColor}` // Set the box-shadow if the LED is on
      : `0 0 10px ${newDataLedStore.offColor}, 0 0 20px ${newDataLedStore.offColor}`, // Set the box-shadow if the LED is off
  };

  // Return the JSX structure for the LED component
  return (
    <div className="led-container"> {/* Container for the LED component */}
      <div className="led-box"> {/* Box containing the LED and its label */}
        <div className="led" style={ledStyle} onClick={newDataLedStore.blink}></div> {/* LED element with the blink function on click */}
        <p>{newDataLedStore.isOn ? 'ON' : 'OFF'}</p> {/* Label indicating the LED state */}
      </div>
    </div>
  );
});

// Export the SimpleLed component as the default export
export default SimpleLed;


frontEnd/SyphaxFrontEnd/src/Components/SignInForm : Contains components related to the sign-in form for user authentication.
frontEnd/SyphaxFrontEnd/src/Components/SignInForm/SignInForm.jsx

// role: Provides the sign-in form component for user authentication.

// eslint-disable-next-line no-unused-vars
import React from 'react';
// Import StyledEngineProvider from MUI for styling
import { StyledEngineProvider } from '@mui/material/styles';
// Import the stylesheet for the SignInForm component
import '../../assets/styleSheets/signInForm.css';
// Import the SignInHeader component
import SignInHeader from './SignInHeader.jsx';
// Import observer from mobx-react to observe changes in MobX store
import { observer } from 'mobx-react';
// Import the loginStore from MobX to manage the login state
import { loginStore } from '../../mobxStores/loginStore.jsx';
// Import MUI components for the form
import {
  Checkbox,
  TextField,
  FormControlLabel,
  Paper,
  Button,
  Box
} from '@mui/material';

/**
 * SignInForm component.
 * 
 * This functional component renders a sign-in form for user authentication.
 * It uses MobX to manage the state and MUI for styling and form elements.
 * 
 * @returns {JSX.Element} The rendered sign-in form component.
 */
const SignInForm = observer(function SignInForm() {
  return (
    <div>
      {/* Display error message if there is any */}
      <Box
        id="loginErrorTextField"
        sx={{
          color: 'red',
          border: loginStore.errorBorder,
          textAlign: 'center',
          padding: '8px',
          marginBottom: '16px',
        }}
      >
        {loginStore.errorText}
      </Box>
      
      {/* Paper component to contain the form elements */}
      <Paper className="GridContainer">
        
        {/* Render the SignInHeader component */}
        <SignInHeader/>

        {/* TextField for user email input */}
        <TextField 
          className="UserField"
          label="User e-mail"
          onChange={loginStore.onUserEmailChanged}
        />
        
        {/* TextField for password input */}
        <TextField 
          className="passwordField" 
          label="Password" 
          type="password"
          onChange={loginStore.onPasswordChanged}
        />
        
        {/* FormControlLabel for the 'Keep me logged in' checkbox */}
        <FormControlLabel 
          className="rememberMeField"
          control={
            <Checkbox
              onChange={loginStore.onHandleStayLogged}
              inputProps={{ 'aria-label': 'primary checkbox' }}
            />
          }
          label="Keep me logged in"
        />
        
        {/* Button to submit the login form */}
        <StyledEngineProvider>
          <Button 
            className="LoginButton" 
            variant="contained" 
            onClick={loginStore.onSubmitLogin}
          > 
            Login 
          </Button>
        </StyledEngineProvider> 
      </Paper>
    </div>
  );
});

// Export the SignInForm component as the default export
export default SignInForm;


frontEnd/SyphaxFrontEnd/src/Components/SignInForm/SignInHeader.jsx

// role: Provides a basic header for a login box.

// Import React to create the component
// eslint-disable-next-line no-unused-vars
import React from 'react';
// Import the stylesheet for the SignInHeader component
import '../../assets/styleSheets/signInHeader.css';

/**
 * SignInHeader component.
 * 
 * This functional component renders a header for the login box,
 * including a logo and a title.
 * 
 * @returns {JSX.Element} The rendered header component.
 */
const SignInHeader = () => {
    return (
        <div className="SignInHeaderContainer">
            {/* Logo image for the header */}
            <img className="Logo" src="src/assets/Images/logoElyteq.png" alt="Elyteq Logo" />
            
            {/* Title for the header */}
            <div className="Title">Elyeq Syphax Gateway</div>
        </div>
    );
};

// Export the SignInHeader component as the default export
export default SignInHeader;


frontEnd/SyphaxFrontEnd/src/Components/containers : This directory contains containers and higher roder components to encapsulate other components (for example ProtectedContainer.jsx)
frontEnd/SyphaxFrontEnd/src/Components/containers/ProtectedContainer.jsx

// role: Higher-Order Component (HOC) that wraps any component to check the access token before rendering it using MobX.

import  { Component } from 'react'; // Import React library
import { observer } from 'mobx-react'; // Import observer from MobX for observing state changes
import authStore from '../../mobxStores/authStore'; // Import the authentication store

/**
 * ProtectedContainer HOC.
 * 
 * This higher-order component wraps around any component to check the access token before rendering it.
 * If the token is invalid, it logs out the user and redirects to the login page.
 * 
 * @param {React.ComponentType} WrappedComponent - The component to be wrapped and protected.
 * @returns {React.ComponentType} The protected component.
 */
const ProtectedContainer = (WrappedComponent) => {
  class ProtectedComponent extends Component {
    async componentDidMount() {
      await authStore.checkAuthAndRedirect(); // Check authentication and redirect if necessary
    }

    render() {
      return authStore.token ? <WrappedComponent {...this.props} /> : null; // Render the wrapped component if authenticated
    }
  }

  return observer(ProtectedComponent);
};

export default ProtectedContainer;


frontEnd/SyphaxFrontEnd/src/Components/DashBoard : Contains components related to the dashboard for displaying drilling parameters and gas analysis.
frontEnd/SyphaxFrontEnd/src/Components/DashBoard/DashBoard.jsx

// role: Component for displaying the dashboard with tabs for different drilling parameters and gas analysis.

// Import Tabs component from MUI for tab navigation
import Tabs from '@mui/material/Tabs';
// Import Tab component from MUI for individual tabs
import Tab from '@mui/material/Tab';
// Import Box component from MUI for layout
import Box from '@mui/material/Box';
// Import observer from MobX for observing state changes
import { observer } from 'mobx-react';
// Import the dashboard store from MobX to manage dashboard state
import { dashBoardStore } from '../../mobxStores/dashBoardStore';
// Import CustomTabPanel component for displaying tab content
import CustomTabPanel from './CustomTabPanel';
// Import SimpleLed component to display an LED indicator
import SimpleLed from '../Leds and Switches/SimpleLed';

/**
 * Accessibility props function.
 * 
 * Generates accessibility properties for each tab to enhance usability.
 * 
 * @param {number} index - The index of the tab.
 * @returns {object} Accessibility properties for the tab.
 */
function a11yProps(index) {
  return {
    id: `simple-tab-${index}`, // Unique ID for the tab
    'aria-controls': `simple-tabpanel-${index}`, // ARIA controls for the associated tab panel
  };
}

/**
 * DashBoard component.
 * 
 * This functional component renders the dashboard with tabs for different drilling parameters and gas analysis.
 * It observes the state from the dashBoardStore to manage tab changes and display the appropriate content.
 * It also includes a status bar with a SimpleLed component that is always visible at the bottom.
 * 
 * @returns {JSX.Element} The rendered dashboard component.
 */
const DashBoard = observer(function DashBoard() {
  return (
    // Container for the dashboard
    <Box sx={{ width: '100%', display: 'flex', flexDirection: 'column', height: '100vh' }}>
      {/* Container for the tabs */}
      <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
        <Tabs 
          value={dashBoardStore.tabSheetIndex} // Bind the selected tab index to the store
          onChange={dashBoardStore.onHandleDashBoardTabsheetChanged} // Handle tab changes using the store's method
          aria-label="elyteq Syphax" // ARIA label for accessibility
        >
          <Tab label="Drilling parameters (time)" {...a11yProps(0)} /> {/* Tab for drilling parameters (time) */}
          <Tab label="Drilling parameters (depth)" {...a11yProps(1)} /> {/* Tab for drilling parameters (depth) */}
          <Tab label="Gaz analysis" {...a11yProps(2)} /> {/* Tab for gas analysis */}
        </Tabs>
      </Box>
      {/* Container for the tab panels */}
      <Box sx={{ flex: 1 }}>
        <CustomTabPanel value={dashBoardStore.tabSheetIndex} index={0}> {/* Panel for the first tab */}
          Item One
        </CustomTabPanel>
        <CustomTabPanel value={dashBoardStore.tabSheetIndex} index={1}> {/* Panel for the second tab */}
          Item Two
        </CustomTabPanel>
        <CustomTabPanel value={dashBoardStore.tabSheetIndex} index={2}> {/* Panel for the third tab */}
          Item Three
        </CustomTabPanel>
      </Box>
      {/* Status bar container */}
      <Box sx={{ borderTop: 1, borderColor: 'divider', padding: '10px', display: 'flex', alignItems: 'center' }}>
        <SimpleLed /> {/* Add the SimpleLed component in the status bar */}
      </Box>
    </Box>
  );
});

// Export the DashBoard component
export default DashBoard;


frontEnd/SyphaxFrontEnd/src/Components/DashBoard/CustomTabPanel.jsx

// role: Provides a custom tab panel component for displaying content in different tabs.

// Import observer from MobX to create an observer component that reacts to state changes in MobX stores.
import { observer } from 'mobx-react';
// Import the custom tab store from MobX which contains the state for the tab panels.
import tabStore from '../../mobxStores/customTabStore';
// Import the Box component from Material-UI (MUI) for layout and styling.
import Box from '@mui/material/Box';

/**
 * CustomTabPanel component.
 * 
 * This functional component renders the content of a tab panel.
 * It is an observer component that reacts to changes in the tab store's state.
 * 
 * @param {object} props - The properties passed to the component.
 * @param {ReactNode} props.children - The content to display within the tab panel.
 * @param {number} props.index - The index of the tab panel.
 * @param {object} [props.other] - Any other properties passed to the component.
 * @returns {JSX.Element} The rendered tab panel component.
 */
const CustomTabPanel = observer(({ children, index, ...other }) => {
  // Destructure the children, index, and any other props passed to the component.

  // Get the current value of the selected tab from the tab store.
  const value = tabStore.value;

  return (
    // Return a div element that serves as the container for the tab panel.
    <div
      role="tabpanel" // ARIA role for accessibility, indicating this div is a tab panel.
      hidden={value !== index} // Hide the panel if it is not the selected tab.
      id={`simple-tabpanel-${index}`} // Unique ID for the tab panel, using the index.
      aria-labelledby={`simple-tab-${index}`} // ARIA attribute to link the tab panel with the corresponding tab.
      {...other} // Spread any other props passed to the component onto this div.
    >
      {/* If this tab panel is the selected one, render its children inside a Box component for padding and styling. */}
      {value === index && <Box sx={{ p: 3 }}>{children}</Box>}
    </div>
  );
});

// Export the CustomTabPanel component as the default export.
export default CustomTabPanel;


frontEnd/SyphaxFrontEnd/src/Components/DashBoard/ProtectedDashBoard.jsx

// role: Protected component for the dashboard that checks authentication before rendering.

// Import the ProtectedContainer HOC to protect the component with authentication check
import ProtectedContainer from '../containers/ProtectedContainer';
// Import the DashBoard component
import DashBoard from './DashBoard';

// Create a named protected component for the dashboard
const ProtectedDashBoard = ProtectedContainer(DashBoard);

// Export the named protected dashboard component
export default ProtectedDashBoard;


frontEnd/SyphaxFrontEnd/src/mobxStores : Contains MobX stores for managing application state.
frontEnd/SyphaxFrontEnd/src/mobxStores/playGroundStore.jsx
frontEnd/SyphaxFrontEnd/src/mobxStores/authStore.jsx

// role: MobX store for managing authentication state, including user information and token management.

import { makeObservable, observable, action, runInAction } from 'mobx';

class AuthStore {
  token = localStorage.getItem('SyphaxToken') || null; // Initialize token from localStorage if available
  user = JSON.parse(localStorage.getItem('SyphaxUser')) || null; // Initialize user from localStorage if available
  stayLogged = localStorage.getItem('SyphaxStayLogged') === 'true'; // Initialize stayLogged from localStorage if available

  constructor() {
    makeObservable(this, {
      token: observable, // Make the token property observable
      user: observable, // Make the user property observable
      stayLogged: observable, // Make the stayLogged property observable
      setToken: action, // Make the setToken method an action
      setUser: action, // Make the setUser method an action
      setStayLogged: action, // Make the setStayLogged method an action
      logout: action, // Make the logout method an action
      checkAuth: action, // Make the checkAuth method an action
      checkAuthAndRedirect: action, // Make the checkAuthAndRedirect method an action
    });
    this.checkAuth(); // Check authentication status on initialization
  }

  /**
   * Sets the authentication token.
   * 
   * If a token is provided, it is stored in both the state and localStorage.
   * If no token is provided, the token is removed from both the state and localStorage.
   * 
   * @param {string|null} token - The authentication token.
   */
  setToken(token) {
    this.token = token;
    if (token) {
      localStorage.setItem('SyphaxToken', token); // Store token in localStorage
    } else {
      localStorage.removeItem('SyphaxToken'); // Remove token from localStorage
    }
  }

  /**
   * Sets the user information.
   * 
   * Updates the user state with the provided user information.
   * 
   * @param {object|null} user - The user information.
   */
  setUser(user) {
    this.user = user;
    if (user) {
      localStorage.setItem('SyphaxUser', JSON.stringify(user)); // Store user in localStorage
    } else {
      localStorage.removeItem('SyphaxUser'); // Remove user from localStorage
    }
  }

  /**
   * Sets the stayLogged flag.
   * 
   * Updates the stayLogged state with the provided flag.
   * 
   * @param {boolean} stayLogged - The stayLogged flag.
   */
  setStayLogged(stayLogged) {
    this.stayLogged = stayLogged;
    localStorage.setItem('SyphaxStayLogged', stayLogged); // Store stayLogged flag in localStorage
  }

  /**
   * Logs out the user.
   * 
   * Clears the authentication token and user information from the state and localStorage.
   */
  logout() {
    this.setToken(null); // Clear token
    this.setUser(null); // Clear user information
    localStorage.removeItem('SyphaxStayLogged'); // Remove stayLogged flag from localStorage
  }

  /**
   * Checks the authentication status on page load.
   * 
   * Retrieves the token from localStorage, validates it with the backend,
   * and updates the state accordingly.
   */
  async checkAuth() {
    const token = localStorage.getItem('SyphaxToken');
    if (token) {
      try {
        const response = await fetch('http://localhost:5010/api/auth/verifyToken', {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
        if (!response.ok) {
          throw new Error('Token validation failed');
        }
        const data = await response.json();
        runInAction(() => {
          this.setToken(token);
          this.setUser(data.user);
        });
      } catch (error) {
        console.error('Token validation error', error);
        runInAction(() => {
          this.logout();
        });
      }
    }
  }

  /**
   * Checks the authentication status and redirects to the login page if not authenticated.
   */
  async checkAuthAndRedirect() {
    await this.checkAuth();
    if (!this.token) {
      window.location.href = '/login'; // Redirect to login page
    }
  }
}

const authStore = new AuthStore();
export default authStore;


frontEnd/SyphaxFrontEnd/src/mobxStores/loginStore.jsx

// role: MobX store for managing the login state, including user email, password, and login status.

import { makeObservable, observable, action, runInAction } from 'mobx'; // Import MobX functions for creating observable state and actions
import { login } from '../apis/authApi'; // Import the login function from the API
import authStore from './authStore'; // Import the authentication store

/**
 * LoginStore class.
 * 
 * This class manages the login state, including the user's email, password, and login status.
 * It provides actions to handle changes in email and password, submit the login form, and manage the "stay logged in" option.
 */
export class LoginStore {
  stayLogged = false; // Observable property to store the "stay logged in" status
  loginSuccess = false; // Observable property to store the login success status
  stayLoggedAsText = 'No'; // Observable property to store the "stay logged in" status as text
  userEmail = ''; // Observable property to store the user's email
  userPassword = ''; // Observable property to store the user's password
  errorText = ''; // Observable property to store the error message
  errorBorder = '0px'; // Observable property to store the error border style

  /**
   * Constructor for LoginStore.
   * 
   * Makes the properties and methods observable and actionable using MobX.
   */
  constructor() {
    makeObservable(this, {
      stayLogged: observable, // Make the stayLogged property observable
      stayLoggedAsText: observable, // Make the stayLoggedAsText property observable
      userEmail: observable, // Make the userEmail property observable
      userPassword: observable, // Make the userPassword property observable
      errorText: observable, // Make the errorText property observable
      errorBorder: observable, // Make the errorBorder property observable
      loginSuccess: observable, // Make the loginSuccess property observable
      onUserEmailChanged: action, // Make the onUserEmailChanged method an action
      onPasswordChanged: action, // Make the onPasswordChanged method an action
      onHandleStayLogged: action, // Make the onHandleStayLogged method an action
      onSubmitLogin: action, // Make the onSubmitLogin method an action
    });
  }

  /**
   * Handles changes to the user email input field.
   * 
   * Updates the userEmail property with the new value from the input field.
   * 
   * @param {object} event - The event object from the input field.
   */
  onUserEmailChanged = (event) => {
    this.userEmail = event.target.value; // Update the userEmail state with the input value
  };

  /**
   * Handles changes to the user password input field.
   * 
   * Updates the userPassword property with the new value from the input field.
   * 
   * @param {object} event - The event object from the input field.
   */
  onPasswordChanged = (event) => {
    this.userPassword = event.target.value; // Update the userPassword state with the input value
  };

  /**
   * Handles the submission of the login form.
   * 
   * Sends the login request to the server and updates the authentication state upon success.
   * Updates the error state if the login request fails.
   */
  onSubmitLogin = async () => {
    try {
      const response = await login(this.userEmail, this.userPassword, this.stayLogged); // Send login request
      const data = response.auth; // Correctly access the auth object
      runInAction(() => {
        authStore.setToken(data.accessToken); // Set the authentication token in the authStore
        authStore.setUser(data.user); // Set the user information in the authStore
        authStore.setStayLogged(this.stayLogged); // Set the stayLogged flag in the authStore
        this.errorText = ''; // Clear the error text
        this.errorBorder = '0px'; // Reset the error border style
        this.loginSuccess = true; // Set the login success status to true
      });
    } catch (error) {
      runInAction(() => {
        this.errorText = 'Login Failed!'; // Set the error text to "Login Failed!"
        this.errorBorder = '1px solid red'; // Set the error border style
        this.loginSuccess = false; // Set the login success status to false
      });
      console.error('Login failed', error); // Log the error to the console
    }
  };

  /**
   * Handles changes to the "stay logged in" checkbox.
   * 
   * Updates the stayLogged and stayLoggedAsText properties based on the checkbox status.
   * 
   * @param {object} event - The event object from the checkbox.
   */
  onHandleStayLogged = (event) => {
    this.stayLogged = event.target.checked; // Update the stayLogged state with the checkbox status
    this.stayLogged ? (this.stayLoggedAsText = 'Yes') : (this.stayLoggedAsText = 'No'); // Update the stayLoggedAsText state based on the checkbox status
    console.log('enter on handleStayLogged:' + this.stayLogged); // Log the stayLogged status to the console
  };
}

// Create an instance of LoginStore
export const loginStore = new LoginStore();


frontEnd/SyphaxFrontEnd/src/mobxStores/dashBoardStore.jsx

// role: MobX store for managing the state of the dashboard, including the index of the currently selected tab.

import { makeObservable, observable, action } from 'mobx'; // Import MobX functions for creating observable state and actions

/**
 * DashBoardStore class.
 * 
 * This class manages the state of the dashboard, specifically the index of the currently selected tab.
 * It provides an action to handle changes to the selected tab.
 */
export class DashBoardStore {
  // Observable property to store the index of the currently selected tab
  tabSheetIndex = 0;

  /**
   * Constructor for DashBoardStore.
   * 
   * Makes the properties and methods observable and actionable using MobX.
   */
  constructor() {
    makeObservable(this, {
      tabSheetIndex: observable, // Make the tabSheetIndex property observable
      onHandleDashBoardTabsheetChanged: action // Make the onHandleDashBoardTabsheetChanged method an action
    });
  }

  /**
   * Handles changes to the selected tab.
   * 
   * Updates the tabSheetIndex property with the new value from the tab change event.
   * 
   * @param {object} event - The event object from the tab change.
   * @param {number} newValue - The index of the newly selected tab.
   */
  onHandleDashBoardTabsheetChanged = (event, newValue) => {
    this.tabSheetIndex = newValue; // Update the tabSheetIndex state with the new tab index
  };
}

// Create an instance of DashBoardStore and export it for use in other parts of the application
export const dashBoardStore = new DashBoardStore();


frontEnd/SyphaxFrontEnd/src/mobxStores/simpleLedStore.jsx

// role: MobX store for managing the state of a simple LED component, including on and off colors, on or off LED state, and blink functionality.

// Import necessary functions from MobX
import { makeObservable, observable, action, runInAction } from 'mobx';

/**
 * SimpleLedStore class.
 * 
 * This class manages the state of an LED, including its on/off status and colors.
 */
class SimpleLedStore {
  // Observable properties for LED state and colors
  isOn = false; // Indicates whether the LED is on or off
  onColor = '#00FF00'; // Default on color (green)
  offColor = '#FF0000'; // Default off color (red)

  /**
   * Constructor for SimpleLedStore.
   * 
   * Makes the properties and methods observable and actionable using MobX.
   */
  constructor() {
    makeObservable(this, {
      isOn: observable, // Makes the isOn property observable
      onColor: observable, // Makes the onColor property observable
      offColor: observable, // Makes the offColor property observable
      toggleLed: action, // Makes the toggleLed method an action
      setOnColor: action, // Makes the setOnColor method an action
      setOffColor: action, // Makes the setOffColor method an action
      blink: action.bound, // Makes the blink method an action and binds it to the instance
    });
  }

  /**
   * Toggles the on/off state of the LED.
   */
  toggleLed = () => {
    this.isOn = !this.isOn; // Toggles the isOn state between true and false
  };

  /**
   * Sets the on color of the LED.
   * 
   * @param {string} color - The new on color.
   */
  setOnColor = (color) => {
    this.onColor = color; // Sets the onColor to the provided color
  };

  /**
   * Sets the off color of the LED.
   * 
   * @param {string} color - The new off color.
   */
  setOffColor = (color) => {
    this.offColor = color; // Sets the offColor to the provided color
  };

  /**
   * Blinks the LED.
   * 
   * If the LED is on, it turns it off. Then it turns the LED on, waits for 500 milliseconds, and turns it off again.
   */
  blink = () => {
    if (this.isOn) { // Checks if the LED is currently on
      this.isOn = false; // Turns the LED off if it is currently on
    }
    this.isOn = true; // Turns the LED on
    setTimeout(() => { // Waits for 500 milliseconds before turning the LED off
      runInAction(() => {
        this.isOn = false; // Turns the LED off
      });
    }, 500); // 500 milliseconds delay
  };
}

// Create an instance of SimpleLedStore and export it for use in other parts of the application
const newDataLedStore = new SimpleLedStore();
export default newDataLedStore;


frontEnd/SyphaxFrontEnd/src/mobxStores/customTabStore.jsx

// role: MobX store for managing the state of a custom tab component, including the index of the currently selected tab.

import { makeObservable, observable, action } from 'mobx'; // Import MobX functions for creating observable state and actions

/**
 * CustomTabStore class.
 * 
 * This class manages the state of a custom tab component, specifically the index of the currently selected tab.
 * It provides an action to update the selected tab index.
 */
class CustomTabStore {
  // Observable property to store the index of the currently selected tab
  value = 0;

  /**
   * Constructor for CustomTabStore.
   * 
   * Makes the properties and methods observable and actionable using MobX.
   */
  constructor() {
    makeObservable(this, {
      value: observable, // Make the value property observable
      setValue: action, // Make the setValue method an action
    });
  }

  /**
   * Sets the index of the selected tab.
   * 
   * Updates the value property with the new tab index.
   * 
   * @param {number} newValue - The index of the newly selected tab.
   */
  setValue(newValue) {
    this.value = newValue; // Update the value state with the new tab index
  }
}

// Create an instance of CustomTabStore and export it for use in other parts of the application
const tabStore = new CustomTabStore();
export default tabStore;


frontEnd/SyphaxFrontEnd/src/apis : Contains API functions for interacting with backend services.
frontEnd/SyphaxFrontEnd/src/apis/authApi.jsx
frontEnd/SyphaxFrontEnd/src/apis/refreshToken.jsx

// role: Contains the function to refresh the access token using the refresh token.

import { LOGIN_API_URL } from '../globals/globals'; // Import the login API URL from the global constants

/**
 * Refreshes the access token using the refresh token.
 *
 * @returns {Promise<Object>} The response data containing the new access token and user data.
 */
export const refreshAccessToken = async () => {
  try {
    // Send a POST request to the refresh token endpoint to obtain a new access token
    const response = await fetch(`${LOGIN_API_URL}/refreshToken`, {
      method: 'POST', // Use the POST method for the request
      credentials: 'include', // Include credentials (cookies) in the request
      headers: {
        'Content-Type': 'application/json' // Set the content type to JSON
      }
    });

    // Check if the response status is not OK (status code is not in the range 200-299)
    if (!response.ok) {
      throw new Error('Failed to refresh access token'); // Throw an error if the request failed
    }

    // Parse the response data as JSON
    const data = await response.json();
    return data; // Return the parsed data containing the new access token and user data
  } catch (error) {
    console.error('Error refreshing access token:', error); // Log any errors that occur during the request
    throw error; // Rethrow the error to be handled by the caller
  }
};


frontEnd/SyphaxFrontEnd/src/webSockets : Contains WebSocket client setup for real-time communication with the backend server.
frontEnd/SyphaxFrontEnd/src/webSockets/websocket.jsx

// role: WebSocket client setup for real-time communication with the backend server.

// Import the WebSocket client from the 'socket.io-client' library
import { io } from "socket.io-client";
// Import the authentication store from MobX to manage authentication state
import authStore from '../mobxStores/authStore';
// Import the WebSocket URL from the global configuration
import { WEB_SOCKET_URL } from "../globals/globals";
import { refreshAccessToken } from "../apis/refreshToken";

// Initialize the WebSocket connection using the provided URL
const socket = io(WEB_SOCKET_URL);

/**
 * Event listener for WebSocket connection.
 * Logs the connection status and socket ID to the console.
 */
socket.on('connect', () => {
  console.log('Connected to WebSocket server');
  // Optionally, we could send the socket ID to the backend for association with user sessions
  console.log('Socket ID:', socket.id);
});

/**
 * Handles token invalidation and expiration.
 * Logs the user out and clears the local storage.
 *
 * @param {string} message - The message received from the server indicating an invalid or expired token.
 */
const handleInvalidToken = async (message) => {
  console.log('Received token invalid/expired message:', message);
  
  try {
    // Attempt to refresh the access token using the refresh token
    const data = await refreshAccessToken();
    authStore.setToken(data.accessToken);
    authStore.setUser(data.userData);
    console.log('Access token refreshed successfully');
  } catch (error) {
    // If refresh fails, logout the user
    console.log('Failed to refresh access token, logging out user');
    authStore.logout();
    // Clear any token in local storage
    localStorage.removeItem('SyphaxToken');
    // Display an alert to the user with the received message
    alert(message);
  }
};

// Event listener for 'invalidToken' messages
socket.on('invalidToken', handleInvalidToken);

// Event listener for 'tokenExpired' messages
socket.on('tokenExpired', handleInvalidToken);

/**
 * Event listener for WebSocket disconnection.
 * Logs the disconnection status to the console.
 */
socket.on('disconnect', () => {
  console.log('Disconnected from WebSocket server');
});

// Export the initialized WebSocket connection for use in other modules
export default socket;


frontEnd/SyphaxFrontEnd/src/globals : Contains global constants and some configuration for the frontend application.
frontEnd/SyphaxFrontEnd/src/globals/globals.jsx

// role: Contains global constants for API and WebSocket URLs used in the application.

/**
 * The URL for the login API endpoint.
 * 
 * This URL is used to send login requests to the backend server.
 * @constant {string}
 */
export const LOGIN_API_URL = 'http://localhost:5010/api/auth';

/**
 * The URL for the WebSocket connection.
 * 
 * This URL is used to establish a WebSocket connection with the backend server.
 * @constant {string}
 */
export const WEB_SOCKET_URL = 'http://localhost:5010';


backEnd : Root directory of the backEnd
backEnd/authentificationServices : Contains services for handling user authentication, including JWT token management and encryption.
backEnd/authentificationServices/jwtService.mjs
backEnd/authentificationServices/authSrv.mjs

// role: This file handles user authentication, verifying credentials, generating tokens, and refreshing tokens.

// Importing bcrypt library for password hashing and comparison.
import bcrypt from "bcrypt";

// Importing sign and verifyToken functions from jwtService to generate and verify JWT tokens.
import { sign, verifyToken } from "./jwtService.mjs";

// Importing AES encryption and decryption functions from cryptoService.
import { cryptoAESEncryption, cryptoAESDecryption } from "./cryptoService.mjs";

// Importing functions to get user by email and ID from the database model.
import { getUserByEmail, getUserByUserId } from "../db/authModel.mjs";

// Importing UI functions to display messages in the terminal.
import { displayError, displayMenu, displaySucces } from "../terminalUi/terminalUi.mjs";

// Importing function to send messages to client via websocket.
import { sendMessageToClient } from "../mainServer/websocketUtils.mjs";
import { MESSAGE_EVENTS, MESSAGE_STRINGS } from "../globals/globalWebSocket.mjs"; // Import WebSocket constants

// Importing function to get and validate native program credentials.
import { getNativeProgramByKey } from "../db/nativeProgramModel.mjs";

/**
 * Authenticates a user by verifying email and password, and generates tokens.
 * 
 * @param {string} email - The email of the user to authenticate.
 * @param {string} password - The password of the user to authenticate.
 * @param {number} expiryTime - The expiration time for the refresh token.
 * @param {string} socketId - The socket ID of the client for WebSocket communication.
 * @returns {Object|null} - Returns an object with tokens and user data if authentication is successful, otherwise null.
 */
export async function authenticateUser(email, password, expiryTime, socketId) {
  // Check if email, password, or expiryTime is missing
  if (!email || !password || !expiryTime) {
    displayError(true, 'User cannot be identified'); // Display error message
    if (socketId) {
      sendMessageToClient(socketId, MESSAGE_EVENTS.LOGIN_FAILED, MESSAGE_STRINGS.LOGIN_FAILED); // Send message to client
    }
    return null; // Return null indicating failure
  }

  try {
    // Fetch user details by email
    const user = await getUserByEmail(email);
    const dbHash = user.u_password; // Get password hash from user data
    displaySucces(true, 'Password hash:\n'); // Display success message
    displaySucces(false, dbHash); // Display the password hash
    if (user.u_email !== email || !dbHash) {
      displayError(false, '\nWrong email or password is null\n'); // Display error for wrong email or missing password
      if (socketId) {
        sendMessageToClient(socketId, MESSAGE_EVENTS.LOGIN_FAILED, MESSAGE_STRINGS.LOGIN_FAILED); // Send message to client
      }
      return null; // Return null indicating failure
    }

    // Replace PHP hash prefix to be compatible with bcrypt
    const hash = dbHash.replace(/^\$2y(.+)$/i, "$2b$1");

    // Compare provided password with stored hash
    const verified = await bcrypt.compare(password, hash).catch(() => false);

    if (!verified) {
      displayError('\nPassword not verified\n'); // Display error if password verification fails
      if (socketId) {
        sendMessageToClient(socketId, MESSAGE_EVENTS.LOGIN_FAILED, MESSAGE_STRINGS.LOGIN_FAILED); // Send message to client
      }
      return null; // Return null indicating failure
    }

    // Prepare user data for token generation
    const userData = {
      id: user.u_user_id,
      name: user.u_name,
      email: user.u_email,
      mobile: user.u_mobile,
      image: user.u_image,
    };

    displaySucces(false, '\nUser data:\n'); // Display user data success message
    displaySucces(false, JSON.stringify(userData)); // Display user data
    displaySucces(false, '\n\nUser ID:\n'); // Display user ID success message
    displaySucces(false, JSON.stringify(user.u_user_id)); // Display user ID

    // Encrypt user data and user ID
    const encUser = await cryptoAESEncryption(JSON.stringify(userData)).catch(() => null);
    const encUserId = await cryptoAESEncryption(user.u_user_id).catch(() => null);

    displaySucces(false, '\n\nEncrypted data:\n'); // Display encrypted data success message
    displaySucces(false, encUser); // Display encrypted user data
    displaySucces(false, '\nEncrypted ID:\n'); // Display encrypted ID success message
    displaySucces(false, encUserId); // Display encrypted user ID

    // Generate refresh and access tokens
    const refreshToken = await sign(encUserId, expiryTime).catch(() => null); // 1 day expiration for refresh token
    const accessToken = await sign(encUser, 2 * 60).catch(() => null); // 2 minutes expiration for access token

    await displayMenu(true); // Display menu

    // Send success message to the client
    if (socketId) {
      sendMessageToClient(socketId, MESSAGE_EVENTS.LOGIN_SUCCESS, MESSAGE_STRINGS.LOGIN_SUCCESS); // Send message to client
    }

    // Return tokens and user data indicating successful authentication
    return {
      refreshToken: refreshToken,
      accessToken: accessToken,
      user: userData,
      authenticated: true,
    };
  } catch (error) {
    displayError(error); // Display error if exception occurs
    if (socketId) {
      sendMessageToClient(socketId, MESSAGE_EVENTS.LOGIN_FAILED, MESSAGE_STRINGS.LOGIN_FAILED); // Send message to client
    }
    return null; // Return null indicating failure
  }
}

/**
 * Authenticates a native program by verifying its credentials and generates tokens.
 * 
 * @param {string} programKey - The key of the native program to authenticate.
 * @param {string} secret - The secret of the native program to authenticate.
 * @param {number} expiryTime - The expiration time for the refresh token.
 * @returns {Object|null} - Returns an object with tokens and program data if authentication is successful, otherwise null.
 */
export async function authenticateNativeProgram(programKey, secret, expiryTime) {
  // Check if programKey, secret, or expiryTime is missing
  if (!programKey || !secret || !expiryTime) {
    displayError(true, 'Program cannot be identified'); // Display error message
    return null; // Return null indicating failure
  }

  try {
    // Fetch program details by key
    const program = await getNativeProgramByKey(programKey);
    const dbSecret = program.secret; // Get secret hash from program data
    if (program.program_key !== programKey || !dbSecret) {
      displayError(false, '\nWrong program key or secret is null\n'); // Display error for wrong key or missing secret
      return null; // Return null indicating failure
    }

    // Compare provided secret with stored hash
    const verified = await bcrypt.compare(secret, dbSecret).catch(() => false);

    if (!verified) {
      displayError('\nSecret not verified\n'); // Display error if secret verification fails
      return null; // Return null indicating failure
    }

    // Prepare program data for token generation
    const programData = {
      id: program.program_id,
      name: program.program_name,
    };

    displaySucces(false, '\nProgram data:\n'); // Display program data success message
    displaySucces(false, JSON.stringify(programData)); // Display program data

    // Encrypt program data and program ID
    const encProgram = await cryptoAESEncryption(JSON.stringify(programData)).catch(() => null);
    const encProgramId = await cryptoAESEncryption(program.program_id).catch(() => null);

    displaySucces(false, '\n\nEncrypted data:\n'); // Display encrypted data success message
    displaySucces(false, encProgram); // Display encrypted program data
    displaySucces(false, '\nEncrypted ID:\n'); // Display encrypted ID success message
    displaySucces(false, encProgramId); // Display encrypted program ID

    // Generate refresh and access tokens
    const refreshToken = await sign(encProgramId, expiryTime).catch(() => null); // 1 day expiration for refresh token
    const accessToken = await sign(encProgram, 2 * 60).catch(() => null); // 2 minutes expiration for access token

    // Return tokens and program data indicating successful authentication
    return {
      refreshToken: refreshToken,
      accessToken: accessToken,
      program: programData,
      authenticated: true,
    };
  } catch (error) {
    displayError(error); // Display error if exception occurs
    return null; // Return null indicating failure
  }
}

/**
 * Verifies the provided JWT token and sends a message if it is expired.
 *
 * @param {string} token - The JWT token to verify.
 * @param {string} socketId - The socket ID of the client for WebSocket communication.
 * @returns {Object|null} - The decoded token payload or null if verification fails.
 */
export const verifyTokenAndNotify = (token, socketId) => {
  if (!token) { // Checking if the token is provided
    return null; // Returning null if token is not provided
  }

  try {
    const decodedToken = jwt.verify(token, publicKey, { algorithm: "RS256" }); // Verifying the token with the public key and algorithm

    // If token is expired, send a WebSocket message
    if (Date.now() >= decodedToken.exp * 1000) {
      if (socketId) {
        sendMessageToClient(socketId, MESSAGE_EVENTS.TOKEN_EXPIRED, MESSAGE_STRINGS.TOKEN_EXPIRED); // Send message to client
      }
      return null;
    }

    return decodedToken;
  } catch (error) {
    console.error(error); // Logging any error that occurs during token verification
    return null; // Returning null if verification fails
  }
};

/**
 * Verifies the refresh token and generates a new access token if valid.
 *
 * @param {Object} req - The HTTP request object containing headers and cookies.
 * @param {string} socketId - The socket ID of the client for WebSocket communication.
 * @returns {Object} - The response data containing authentication status, updated token, and user data.
 */
export const verifyRefreshToken = async (req, socketId) => {
  let userData = null; // Initializing userData as null

  const responseData = { // Initializing the response data object
    authStatus: 0, // Default authentication status (0: not authenticated)
    updatedToken: false, // Default updated token status (false: token not updated)
    data: {
      accessToken: null, // Placeholder for the access token
      userData: null, // Placeholder for the user data
    },
  };

  let accessTok =
    req.headers?.authorization && req.headers?.authorization.split(" ")[1] // Checking if the authorization header is present
      ? req.headers?.authorization.split(" ")[1] // Extracting the token from the authorization header
      : ""; // Defaulting to an empty string if no token is found

  const refreshTok = req.cookies?.yttmrtck; // Extracting the refresh token from the cookies

  if (!accessTok && !refreshTok) { // Checking if both access token and refresh token are absent
    return responseData; // Returning the default response data
  }

  const accessTokenValid = verifyToken(accessTok, socketId); // Verifying the access token

  if (!accessTokenValid || !accessTokenValid.payload) { // Checking if the access token is invalid or has no payload
    const refreshTokenValid = verifyToken(refreshTok, socketId); // Verifying the refresh token
    if (refreshTokenValid && refreshTokenValid.payload) { // Checking if the refresh token is valid and has a payload
      const userDec = await cryptoAESDecryption(
        refreshTokenValid.payload
      ).catch(() => null); // Decrypting the user data from the refresh token payload

      if (userDec) { // Checking if the user data decryption was successful
        const user = await getUserByUserId(userDec); // Fetching the user data by user ID
        if (user) { // Checking if the user data was retrieved successfully
          const userData = { // Constructing the user data object
            id: user.u_user_id, // User ID
            name: user.u_name, // User name
            email: user.u_email, // User email
            mobile: user.u_mobile, // User mobile
            image: user.u_image, // User image
          };

          const encUser = await cryptoAESEncryption(
            JSON.stringify(userData)
          ).catch(() => null); // Encrypting the user data

          const accessToken = await sign(encUser, 2 * 60).catch(() => null); // Generating a new access token with a short expiry

          responseData.updatedToken = true; // Updating the token status in the response data
          responseData.authStatus = 1; // Updating the authentication status in the response data
          responseData.data.accessToken = accessToken; // Setting the new access token in the response data
          responseData.data.userData = userData; // Setting the user data in the response data
          return responseData; // Returning the updated response data
        }
      }
    }
  } else {
    userData = await cryptoAESDecryption(accessTokenValid.payload).catch(
      () => null
    ); // Decrypting the user data from the access token payload
  }

  if (accessTokenValid && userData) { // Checking if the access token is valid and user data is available
    responseData.authStatus = 1; // Updating the authentication status in the response data
    responseData.data.accessToken = accessTok; // Setting the current access token in the response data
    responseData.data.userData = userData; // Setting the user data in the response data
  }

  return responseData; // Returning the final response data
};


backEnd/authentificationServices/cryptoService.mjs

// role: This file provides functions for AES encryption and decryption using Node.js crypto module.

// Importing the 'crypto' module from Node.js which provides cryptographic functionality.
import crypto from "crypto";

// Exporting an asynchronous function for AES encryption.
export async function cryptoAESEncryption(text) {
  try {
    // Checks if text input is non-empty.
    if (text) {
      const algorithm = "aes-256-cbc";  // Specifies the AES encryption algorithm with a 256-bit key and CBC mode.
      // Generates a cryptographic key from a predefined environment variable 'AES_ENC_KEY' using scrypt algorithm,
      // with 'salt' as the salt, and the number of key bytes specified by 'AES_ENC_SALT' environment variable.
      const key = crypto.scryptSync(
        process.env.AES_ENC_KEY,
        "salt",
        parseInt(process.env.AES_ENC_SALT)
      );
      const iv = crypto.randomBytes(16);  // Generates a 16-byte initialization vector (IV) randomly.
      const cipher = crypto.createCipheriv(algorithm, key, iv);  // Creates a cipher instance using the algorithm, key, and IV.
      let encrypted = cipher.update(text, "utf8", "hex");  // Encrypts the text and outputs it in hexadecimal format.
      encrypted += cipher.final("hex");  // Finalizes the encryption and appends the result.
      return `i$${iv.toString("hex")}$e$${encrypted}`;  // Returns the IV and encrypted data formatted with specific delimiters.
    }
  } catch (error) {
    // Logs any encryption errors to the console.
    console.error(`Error Enc: ${error.message}`);
  }
  return null;  // Returns null if the function fails due to an error or empty input.
}

// Exporting an asynchronous function for AES decryption.
export async function cryptoAESDecryption(encrypted) {
  try {
    // Checks if encrypted input is non-empty.
    if (encrypted) {
      const parts = encrypted.split("$");  // Splits the encrypted string by '$' to extract the IV and encrypted data.
      // Ensures the format is correct: starts with 'i', the IV, 'e', and the encrypted data.
      if (parts.length === 4 && parts[0] === "i" && parts[2] === "e") {
        const iv = Buffer.from(parts[1], "hex");  // Recreates the IV from its hexadecimal string.
        const encryptedData = parts[3];  // Extracts the encrypted data part.
        const algorithm = "aes-256-cbc";  // Specifies the AES decryption algorithm as before.
        // Generates the decryption key as in the encryption function.
        const key = crypto.scryptSync(
          process.env.AES_ENC_KEY,
          "salt",
          parseInt(process.env.AES_ENC_SALT)
        );
        const decipher = crypto.createDecipheriv(algorithm, key, iv);  // Creates a decipher instance using the algorithm, key, and IV.
        let decrypted = decipher.update(encryptedData, "hex", "utf8");  // Decrypts the data to utf8 format from hex.
        decrypted += decipher.final("utf8");  // Finalizes the decryption and appends the result.
        return decrypted;  // Returns the decrypted text.
      } else {
        // Throws an error if the format of the encrypted data does not meet expected standards.
        throw new Error("An error occurred while decrypting the data");
      }
    }
  } catch (error) {
    // Logs any decryption errors to the console.
    console.error(`Error Enc: ${error.message}`);
  }
  return null;  // Returns null if the function fails due to an error or incorrect formatting.
}


backEnd/authentificationServices/tokenHelper.mjs

// role: Helper functions and middleware for verifying JWT tokens and handling authentication for the Syphax backend server.

// Imports the 'verifyRefreshToken' function from a local jwtService module to handle token verification.
import { verifyRefreshToken } from "./jwtService.mjs";
// Imports the 'sendErrorResponse' function from a global utility module to handle error responses uniformly.
import { sendErrorResponse } from "../globals/globals.mjs";
// Imports the WebSocket utility to send messages to specific clients.
import { sendMessageToClient } from '../mainServer/websocketUtils.mjs';

/**
 * Middleware to verify JWT tokens for routes requiring authentication.
 * 
 * This middleware function verifies the JWT token provided in the request.
 * If the token is valid and authentication succeeds, the request proceeds to the next middleware or route handler.
 * If the token is invalid, it sends an appropriate error response and optionally sends a WebSocket message to the client.
 * 
 * @param {Object} req - Express request object containing headers and cookies.
 * @param {Object} res - Express response object used to send responses back to the client.
 * @param {Function} next - Function to pass control to the next middleware or route handler.
 * @returns {Promise<void>}
 */
export const verifyTokenMiddleware = async (req, res, next) => {
  // Calls 'verifyRefreshToken' with the current request to check token validity and get new tokens if necessary.
  const isVerified = await verifyRefreshToken(req);
  // Checks if the token verification was successful and all necessary data is present.
  if (
    isVerified &&
    isVerified.authStatus === 1 &&
    isVerified.data.accessToken &&
    isVerified.data.userData
  ) {
    // If a new access token was issued during the refresh process, update the request object with the new token and user data.
    if (isVerified.updatedToken) {
      req.accessToken = isVerified.data.accessToken;
      req.userData = isVerified.data.userData;
    }
    next(); // Proceeds to the next middleware or route handler since authentication was successful.
  } else {
    // If verification fails, send a WebSocket message to the client if socket-id is provided.
    const socketId = req.headers['socket-id']; // Assuming socket ID is passed in headers
    if (socketId) {
      sendMessageToClient(socketId, 'invalidToken', 'Your token is invalid or expired.');
    }
    return sendErrorResponse(req, res, 401, "Verification failed!");
  }
};

/**
 * Function to verify JWT tokens for static routes.
 * 
 * This function verifies the JWT token provided in the request without passing through the middleware chain.
 * It is typically used for static routes that require user verification.
 * 
 * @param {Object} req - Express request object containing headers and cookies.
 * @returns {Promise<boolean|null>} Returns true if verification is successful, null otherwise.
 */
export const verifyTokenForStatic = async (req) => {
  // Similar to the middleware, it calls 'verifyRefreshToken' to check the validity of the user's tokens.
  const isVerified = await verifyRefreshToken(req);
  // Verifies the token just like the middleware and checks all required fields are present and correct.
  if (
    isVerified &&
    isVerified.authStatus === 1 &&
    isVerified.data.accessToken &&
    isVerified.data.userData
  ) {
    // Updates the request object with new token and user data if a new token was issued.
    if (isVerified.updatedToken) {
      req.accessToken = isVerified.data.accessToken;
      req.userData = isVerified.data.userData;
    }
    return true; // Returns true indicating that the token verification was successful.
  } else {
    // Returns null if the verification process fails, indicating no valid token or user data was available.
    return null;
  }
};


backEnd/terminalUi : Contains terminal UI components for managing the backend server, including user administration.For security reason, there will be no administartion access from the front end
backEnd/terminalUi/terminalUi.mjs

// role: initialize the terminal ui stuff and furnish the main menu for the administrator
import path from 'path';
import { fileURLToPath } from 'url';
import pkg from 'terminal-kit';
import { checkDb } from '../db/userDbManager.mjs';
import { showUserAdderForm,
         displayUsers,
         displayRevokeUserByName,
         displayRestoreUserByName,
         displaySetUserDeletableByName,
         displayDeleteUserByName,
         waitForKeyPress  } from './userAdderForm.mjs';

let terminalReady = false;
let terminalResolve;
let terminalPromise = new Promise(resolve => {
  terminalResolve = resolve;
});


const { terminal } = pkg;

terminal.on('key', function (name, matches, data) {
    if (name === 'CTRL_C') {
        terminal.grabInput(false);  // Stop grabbing input
        terminal.green('\nCTRL+C received, exiting...\n');
        process.exit(0);  // Safely exit the process
    }
});

// Derive __dirname equivalent in ESM
const __dirname = path.dirname(fileURLToPath(import.meta.url));

let progressBar;




// Initialize the terminal and progress bar
async function initializeTerminal() {
    try {
        terminal.clear();
        terminal.green("Welcome to the Syphax backend server, sit back and relax.\n");
        terminal.grabInput({ mouse: 'button' });

        progressBar = terminal.progressBar({
            width: 80,
            title: 'Initialization Progress:',
            eta: true,
            percent: true
        });

        // Your actual initialization logic here
        await new Promise(resolve => setTimeout(resolve, 100));  // Simulated delay

        terminalReady = true;
        terminalResolve(terminal);
    } catch (error) {
        terminalResolve(); // Resolve the promise even on failure to avoid hanging
        console.error("Failed to initialize terminal:", error);
    }
    return progressBar;
}


// Update the progress bar with a specified progress and an optional delay
async function updateProgressBar(progress, delay = 0) {
    await new Promise(resolve => setTimeout(resolve, delay)); // Wait for the delay before updating
    progressBar.update(progress);
}

function getTerminal() {
    return new Promise((resolve, reject) => {
        if (terminalReady) {
            resolve(terminal);
        } else {
            // Wait for terminal to be ready
            terminalPromise.then(resolve).catch(reject);
        }
    });
}
// Finalize initialization by displaying server running information
function finalizeInitialization(port) {
    progressBar.stop();
    terminal.moveTo(1, 3);
    terminal.green(`Syphax backend server running at http://localhost:${port}\n`);

    // Construct the path to the image file
    const imagePath = path.join(__dirname, "../assets/images/Cyberpunk.png");

    // Attempt to draw the image, wrapped in try-catch for error handling
    try {
        terminal.drawImage(imagePath, {
            shrink: {
                width: 100,
                height: 100
                }
        });

        terminal.slowTyping(
            'Everything seems to run smoothly boss!\n',
            { flashStyle: terminal.brightWhite, delay: 60 },
            function () {

                displayMenu(true);
            }
        );
    } catch (error) {
        console.error("Failed to draw image:", error);
    }
}

async function displayMenu(clearScreen) {
    if (clearScreen) {
        terminal.clear();
    }
    const menuItems = ['Show parameters', 'Check DB', 'Show users', 'Revoke user', 'Restore user', 'Create user', 'Set user deletable', 'Delete user', 'Exit'];
    terminal.singleColumnMenu(menuItems, { selectedIndex: 0 }, (error, response) => {
        if (error) {
            terminal.red('An error occurred: ' + error.message + '\n');
            return;
        }
        terminal.green(`You selected: ${response.selectedText}\n`);

        switch (response.selectedIndex) {
            case 0:
                terminal.yellow('Placeholder for show parameters.\n');
                waitForKeyPress(terminal);
                break;
            case 1:
                terminal.yellow('Checking the database:\n');
                checkDb(terminal);
                break;
            case 2:
                displayUsers(terminal);
                break;
            case 3:
                terminal.yellow('Revoking a user:\n');
                displayRevokeUserByName(terminal);
                break;
            case 4:
                terminal.yellow('Restoring a user.\n');
                displayRestoreUserByName(terminal);
                break;
            case 5:
                terminal.yellow('Adding a new user:\n');
                showUserAdderForm(terminal);
                break;
            case 6:
                terminal.yellow('Set user delatable\n');
                displaySetUserDeletableByName(terminal);
                break;
            case 7:
                terminal.yellow('Delete user.\n');
                displayDeleteUserByName(terminal);
                break;
            case 8:
                terminal.yellow('Exiting\n');
                process.exit(0);
                break;
            default:
                terminal.red('No valid option selected.\n');
                waitForKeyPress(terminal);
        }
    });
}

function displayError(clearScreen,message) {
    if (clearScreen) {
        terminal.clear();
    }
    terminal.red(message);
}

function displaySucces(clearScreen,message) {
    if (clearScreen) {
        terminal.clear();
    }
    terminal.green(message);
}


// Ensure all functions I need are correctly exported

export { initializeTerminal, updateProgressBar, finalizeInitialization, getTerminal,  displayMenu, displayError, displaySucces};


backEnd/terminalUi/userAdderForm.mjs
backEnd/terminalUi/inputField.mjs

// role: furnish a simple terminal ui input field for the backend administration

export async function inputField(terminal, prompt, options = {}) {
    terminal(prompt);
    const input = await terminal.inputField(options).promise;
    terminal('\n');
    return input;
}


backEnd/routes : Contains all the backend route handlers for the API.
backEnd/routes/api : Contains API route handlers for the Syphax backend server.
backEnd/routes/api/auth : ontains authentication-related API route handlers.
backEnd/routes/api/auth/auth.mjs

// role: Defines and handles API routes related to authentication for the Syphax backend server.

// Import the express module to create router instances.
import express from "express";
// Import specific controller functions from the AuthController.
import {
  login,
  logoutController,
  verifyTokenController,
} from "../../../controllers/api/AuthController.mjs";

// Create a new router object to handle routes under a specific path.
const router = express.Router();

// Middleware to parse JSON bodies. This lets us handle raw JSON data sent in requests.
router.use(express.json());

// Middleware to parse URL-encoded bodies. `extended: true` allows for rich data objects.
router.use(
  express.urlencoded({
    extended: true,
  })
);

/**
 * Route that handles POST requests on "/login". It uses the `login` function from the imported controllers.
 */
router.post("/login", login);

/**
 * Route that handles GET requests on "/verifyToken". It uses the `verifyTokenController` function from the imported controllers.
 */
router.get("/verifyToken", verifyTokenController);

/**
 * Route that handles GET requests on "/logout". It uses the `logoutController` function from the imported controllers.
 */
router.get("/logout", logoutController);

/**
 * Catch-all route for any other GET requests not previously matched.
 * Responds with a 404 status code and a JSON object describing the error.
 */
router.get("*", function (req, res) {
  res.status(404).json({
    success: false,
    message: "",
    data: null,
    error: {
      code: 404,
      message: "Page not found!",
    },
  });
});

// Export the router as the default export of this module.
export default router;


backEnd/routes/web : 
backEnd/routes/web/main.mjs

// role: Defines and handles API routes for the Syphax backend server, including middleware for authentication and error handling.

// Import the express module to use its functionalities for routing and middleware.
import express from "express";
// Import a controller function to handle requests for dummy data.
import { dummyDataController } from "../../controllers/api/MainController.mjs";
// Import middleware that verifies tokens to secure routes.
import { verifyTokenMiddleware } from "../../authentificationServices/tokenHelper.mjs";

// Create a new router object to handle routes under a specific path prefix.
const router = express.Router();

// Middleware to parse JSON bodies. This allows us to handle JSON input in requests.
router.use(express.json());

// Middleware to parse URL-encoded bodies with the setting `extended: true`.
// This allows for objects and arrays to be URL-encoded which the querystring library does not allow.
router.use(
  express.urlencoded({
    extended: true,
  })
);

/**
 * Route that handles GET requests on "/dummydata".
 * Uses the `verifyTokenMiddleware` to authenticate requests before handling them with `dummyDataController`.
 */
router.get("/dummydata", verifyTokenMiddleware, dummyDataController);

/**
 * Catch-all route for any other GET requests not previously handled.
 * Responds with a 404 status code and a JSON object describing the error.
 */
router.get("*", function (req, res) {
  res.status(404).json({
    success: false,
    message: "",
    data: null,
    error: {
      code: 404,
      message: "Page not found!",
    },
  });
});

// Export the configured router as the default export of this module.
export default router;


backEnd/db : Contains database access tools and models for interacting with the backend database.
backEnd/db/authModel.mjs

// role: retrieve a user from the db to check its existence and its status. A part of the security.

// Import the database pool object from the configuration file
import pool from "./userDbManager.mjs";

/**
 * Fetches a user from the database by their email.
 *
 * @param {string} email - The email of the user to fetch.
 * @returns {Object|null} - The user object if found, otherwise null.
 */
export const getUserByEmail = async (email) => {
  if (!email) { // Check if the email input is null or undefined, and return null if it is
    return null;
  }

  try {
    const authenticated = await pool.query(
      "SELECT * from user WHERE u_email = ? AND u_deleted_status = 0 AND u_status = 1",
      [email]
    ); // Perform a SQL query to find the user in the database who matches the given email and has not been deleted (`u_deleted_status = 0`) and is active (`u_status = 1`)
    const [rows] = authenticated; // Destructure the result to get the rows from the query result

    if (Object.keys(rows).length === 0) { // Check if the query returned any rows; if none, return null
      return null;
    }
    return rows[0]; // Return the first row of the results (the user data)
  } catch (error) {
    return null; // If an error occurs during the database operation, return null
  }
};

/**
 * Fetches a user from the database by their user ID.
 *
 * @param {number} refId - The user ID of the user to fetch.
 * @returns {Object|null} - The user object if found, otherwise null.
 */
export const getUserByUserId = async (refId) => {
  if (!refId) { // Check if the reference ID input is null or undefined, and return null if it is
    return null;
  }

  try {
    const authenticated = await pool.query(
      "SELECT * from user WHERE u_user_id = ? AND u_deleted_status = 0 AND u_status = 1",
      [refId]
    ); // Perform a SQL query to find the user in the database who matches the given user ID and has not been deleted (`u_deleted_status = 0`) and is active (`u_status = 1`)
    const [rows] = authenticated; // Destructure the result to get the rows from the query result

    if (Object.keys(rows).length === 0) { // Check if the query returned any rows; if none, return null
      return null;
    }
    return rows[0]; // Return the first row of the results (the user data)
  } catch (error) {
    return null; // If an error occurs during the database operation, return null
  }
};


backEnd/db/nativeProgramModel.mjs

// role: This file handles database operations related to native programs, including registration and validation, ensuring secure association with user data.

// Import the database pool object from the configuration file
import pool from "./userDbManager.mjs"; // Assuming userDbManager exports the pool
import { v4 as uuidv4 } from 'uuid'; // Import to generate unique IDs

/**
 * Creates the native programs table if it does not exist.
 *
 * @param {Object} pool - The MySQL connection pool.
 * @returns {Promise<void>}
 */
async function createNativeProgramsTable(pool) {
    // Execute the SQL query to create the native programs table if it does not exist
    await pool.query(`
        CREATE TABLE IF NOT EXISTS native_programs (
            program_id INT AUTO_INCREMENT PRIMARY KEY,   // Define the primary key for the table
            user_id VARCHAR(255) NOT NULL,               // Define the user ID column as a foreign key
            user_name VARCHAR(255) NOT NULL,             // Define the user name column
            user_email VARCHAR(255) NOT NULL,            // Define the user email column
            program_name VARCHAR(255) NOT NULL,          // Define the program name column
            program_key VARCHAR(255) UNIQUE NOT NULL,    // Define the program key column with a unique constraint
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, // Define the creation timestamp
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, // Define the update timestamp
            FOREIGN KEY (user_id) REFERENCES user(u_user_id) // Set user_id as a foreign key referencing user table
        );
    `); // End of SQL query
}

/**
 * Registers a new native program linked to a user.
 *
 * @param {string} userId - The user ID to link the native program to.
 * @param {string} userName - The name of the user.
 * @param {string} userEmail - The email of the user.
 * @param {string} programName - The name of the native program.
 * @returns {Object|null} - The native program object if registration is successful, otherwise null.
 */
export const registerNativeProgram = async (userId, userName, userEmail, programName) => {
    if (!userId || !userName || !userEmail || !programName) { // Check if any input is null or undefined
        return null; // Return null if any input is invalid
    }

    const programKey = uuidv4(); // Generate a unique program key

    try {
        // Perform a SQL query to insert the new native program
        const result = await pool.query(
            "INSERT INTO native_programs (user_id, user_name, user_email, program_name, program_key) VALUES (?, ?, ?, ?, ?)",
            [userId, userName, userEmail, programName, programKey] // Provide the query values
        );

        if (result[0].affectedRows === 0) { // Check if the insertion was successful
            return null; // Return null if no rows were affected
        }

        // Return the inserted native program data
        return {
            program_id: result[0].insertId, // ID of the newly inserted program
            user_id: userId,                // ID of the user linked to the program
            user_name: userName,            // Name of the user
            user_email: userEmail,          // Email of the user
            program_name: programName,      // Name of the program
            program_key: programKey,        // Unique key of the program
            created_at: new Date(),         // Creation timestamp
            updated_at: new Date(),         // Update timestamp
        };
    } catch (error) {
        console.error('Error registering native program:', error); // Log the error if insertion fails
        return null; // Return null if an error occurs
    }
};

/**
 * Fetches a native program by its program key.
 *
 * @param {string} programKey - The key of the native program to fetch.
 * @returns {Object|null} - The native program object if found, otherwise null.
 */
export const getNativeProgramByKey = async (programKey) => {
    if (!programKey) { // Check if the program key input is null or undefined
        return null; // Return null if the program key is invalid
    }

    try {
        // Perform a SQL query to find the native program by its key
        const result = await pool.query(
            "SELECT * FROM native_programs WHERE program_key = ?",
            [programKey] // Provide the program key as a query value
        );
        const [rows] = result; // Destructure the result to get the rows from the query result

        if (Object.keys(rows).length === 0) { // Check if the query returned any rows
            return null; // Return null if no rows were found
        }
        return rows[0]; // Return the first row of the results (the native program data)
    } catch (error) {
        console.error('Error fetching native program by key:', error); // Log the error if the query fails
        return null; // Return null if an error occurs
    }
};

/**
 * Validates data sent from a native program by its program key.
 *
 * @param {string} programKey - The key of the native program to validate.
 * @returns {Object|null} - The native program object if validation is successful, otherwise null.
 */
export const validateNativeProgram = async (programKey) => {
    const program = await getNativeProgramByKey(programKey); // Fetch the native program by its key
    if (!program) { // Check if the native program exists
        return null; // Return null if the native program does not exist
    }

    // Additional validation logic can be added here

    return program; // Return the valid native program data
};

/**
 * Fetches all native programs linked to a specific user.
 *
 * @param {string} userId - The user ID to fetch the native programs for.
 * @returns {Array|null} - An array of native programs if found, otherwise null.
 */
export const getNativeProgramsByUserId = async (userId) => {
    if (!userId) { // Check if the user ID input is null or undefined
        return null; // Return null if the user ID is invalid
    }

    try {
        // Perform a SQL query to find native programs by user ID
        const result = await pool.query(
            "SELECT * FROM native_programs WHERE user_id = ?",
            [userId] // Provide the user ID as a query value
        );
        const [rows] = result; // Destructure the result to get the rows from the query result

        if (Object.keys(rows).length === 0) { // Check if the query returned any rows
            return null; // Return null if no rows were found
        }
        return rows; // Return the rows of the results (the native programs data)
    } catch (error) {
        console.error('Error fetching native programs by user ID:', error); // Log the error if the query fails
        return null; // Return null if an error occurs
    }
};

/**
 * Initializes the database by creating the native programs table if it does not exist.
 *
 * @returns {Promise<void>}
 */
export const initializeDatabase = async () => {
    try {
        await createNativeProgramsTable(pool); // Create the native programs table if it does not exist
        console.log("Native programs table initialized."); // Log the successful initialization
    } catch (error) {
        console.error("Error initializing native programs table:", error); // Log the error if initialization fails
    }
};


backEnd/db/userDbManager.mjs

// role: helper functions to create, remove, revoke, restore, etc... a user inside the db (administration)

// Import what is needed to generate unique ids
import { v4 as uuidv4 } from 'uuid';
// Import a crypto library for hashing passwords
import bcrypt from "bcrypt";
// Import the mysql module with promise support
import mysql from "mysql2/promise";
import { getTerminal, displayMenu } from '../terminalUi/terminalUi.mjs'; // Import terminal UI functions
import { waitForKeyPress } from '../terminalUi/userAdderForm.mjs'; // Import function to wait for key press
import { DBIP, DBNAME, DBUSER, DBPASSWORD, CONNECTLIMIT, DBUSERTABLE } from '../mainServer/config.mjs'; // Import database configuration

// Create a noDbPool with no DB in case we need to recreate the db
const noDbPool = mysql.createPool({
    host: DBIP, // Database server address
    user: DBUSER, // Database user based on application mode (production or development)
    password: DBPASSWORD, // DB password based on application mode
    waitForConnections: true, // When no connections are available, wait rather than immediately throwing an error
    connectionLimit: CONNECTLIMIT || 10, // Maximum number of connections to create at once (fallback is 10)
    queueLimit: 0 // Maximum number of connection requests the pool will queue before returning an error
});

// Create a connection pool with MySQL database parameters
const pool = mysql.createPool({
  host: DBIP, // Database server address
  user: DBUSER, // Database user based on application mode (production or development)
  password: DBPASSWORD, // DB password based on application mode
  database: DBNAME, // Determine which database to connect to based on application mode
  waitForConnections: true, // When no connections are available, wait rather than immediately throwing an error
  connectionLimit: CONNECTLIMIT || 10, // Maximum number of connections to create at once (fallback is 10)
  queueLimit: 0 // Maximum number of connection requests the pool will queue before returning an error
});

/**
 * Creates the user table if it does not exist.
 *
 * @param {Object} pool - The MySQL connection pool.
 * @param {string} tableName - The name of the table to create.
 * @returns {Promise<void>}
 */
async function createUserTable(pool, tableName) {
    await pool.query(`
        CREATE TABLE ${tableName} (
            id int NOT NULL AUTO_INCREMENT,
            u_user_id varchar(255) DEFAULT '',
            u_name varchar(255) NOT NULL,
            u_email varchar(255) NOT NULL,
            u_mobile bigint(20) NULL,
            u_password varchar(255) NULL,
            u_image varchar(150) DEFAULT '',
            u_status int(11) DEFAULT 1,
            u_deleted_status int(11) DEFAULT 0,
            u_created_at timestamp DEFAULT current_timestamp(),
            u_updated_at timestamp NULL,
            PRIMARY KEY(id)
        );
    `);
}

/**
 * Checks and manages the database and table setup.
 *
 * @param {Object} aTerminal - The terminal interface.
 * @returns {Promise<void>}
 */
export async function checkDb(aTerminal) {
    aTerminal.clear(); // Clear the terminal
    try {
        // Check if the database exists
        const dbResult = await noDbPool.query(`SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '${DBNAME}'`);
        if (!dbResult[0].length) {
            aTerminal.yellow(`Database '${DBNAME}' does not exist. Creating...\n`);
            try {
                // Temporarily connect to a default database to execute the creation
                aTerminal.green(`Database '${DBNAME}' has been successfully created...\n`);
                await noDbPool.query(`CREATE DATABASE IF NOT EXISTS ${DBNAME}`);
            } catch (error) {
                throw new Error(`Failed to create database: ${error.message}`);
            }
        } else {
            aTerminal.green(`Database '${DBNAME}' exists.\n`);
        }

        // Check if the table exists within the specified database
        const tableResult = await pool.query(`SHOW TABLES LIKE '${DBUSERTABLE}'`);
        if (!tableResult[0].length) {
            aTerminal.yellow(`Table '${DBUSERTABLE}' does not exist. Creating...\n`);
            await createUserTable(pool, DBUSERTABLE);
            aTerminal.green("Table created successfully.\n");
        } else {
            aTerminal.green(`Table '${DBUSERTABLE}' exists.\n`);
        }

        // Query to check user count
        const [results] = await pool.query(`SELECT COUNT(*) AS userCount FROM ${DBUSERTABLE}`);
        const userCount = results[0].userCount;
        aTerminal.green(`User count: ${userCount}\n`);

    } catch (error) {
        aTerminal.red(`Error checking database: ${error.message}\n`);
        if (error.message.includes("Unknown database")) {
            aTerminal.magenta(`last attempt to create the DB ${DBNAME}\n`);
            await createUserDB(pool, DBNAME);
        }
    }

    aTerminal.yellow("Press 'Enter' to return to the menu...");
    aTerminal.inputField({}, (err, input) => {
        displayMenu(true);
    });
}

/**
 * Adds a new user to the database.
 *
 * @param {Object} terminal - The terminal interface.
 * @param {string} u_name - User's name.
 * @param {string} u_email - User's email.
 * @param {string} u_mobile - User's mobile number.
 * @param {string} plainPassword - User's plain text password.
 * @param {string} u_image_path - Path to the user's image.
 * @returns {Promise<void>}
 */
export async function addUser(terminal, u_name, u_email, u_mobile, plainPassword, u_image_path) {
    try {
        const u_user_id = uuidv4(); // Generate a UUID for the user ID
        const saltRounds = 10; // Number of salt rounds for hashing
        const hashedPassword = await bcrypt.hash(plainPassword, saltRounds); // Hash the user's password

        const query = `
        INSERT INTO ${DBUSERTABLE} (
          u_user_id, 
          u_name, 
          u_email, 
          u_mobile, 
          u_password, 
          u_image
        ) VALUES (?, ?, ?, ?, ?, ?);
      `;

        const values = [u_user_id, u_name, u_email, u_mobile, hashedPassword, u_image_path]; // Values to insert into the user table
        const [result] = await pool.query(query, values); // Execute the query with the provided values

        terminal.green(`User successfully added with UUID: ${u_user_id}\n`); // Output success message
        return result; // Return the result of the query
    } catch (error) {
        terminal.red(`Error adding user: ${error.message}\n`); // Output error message
        return null; // Return null if an error occurs
    }
}

/**
 * Retrieves all users from the database.
 *
 * @param {Object} terminal - The terminal interface.
 * @returns {Promise<Array>} An array of user objects.
 */
export async function showUsers(terminal) {
    try {
        const query = `SELECT * FROM ${DBUSERTABLE};`; // Query to select all users
        const [rows] = await pool.query(query); // Execute the query

        terminal.green(`Retrieved ${rows.length} users from the database.\n`); // Output success message
        return rows; // Return the rows of the query result
    } catch (error) {
        terminal.red(`Error retrieving users: ${error.message}\n`); // Output error message
        return []; // Return an empty array if an error occurs
    }
}

/**
 * Revokes a user by name by setting their status to inactive (0).
 * If the exact name is not found, performs a Soundex search to find similar names.
 *
 * @param {Object} terminal - The terminal interface.
 * @param {string} userName - The name of the user to revoke.
 * @returns {Promise<void>}
 */
export async function revokeUserByName(terminal, userName) {
    try {
        // Attempt to revoke user by exact name
        let query = `
        UPDATE ${DBUSERTABLE}
        SET u_status = 0
        WHERE u_name = ?;
      `;

        let values = [userName];
        let [result] = await pool.query(query, values);

        if (result.affectedRows === 0) {
            terminal.red(`No user found with the exact name '${userName}'.\n`);

            // Perform a Soundex search for similar names
            terminal.yellow('Performing a Soundex search for similar names...\n');
            query = `
          SELECT u_name
          FROM ${DBUSERTABLE}
          WHERE SOUNDEX(u_name) = SOUNDEX(?);
        `;
            const [rows] = await pool.query(query, values);

            if (rows.length === 0) {
                terminal.red('No similar names found.\n');
                waitForKeyPress(terminal);
                return null;
            } else {
                terminal.cyan('Found similar names:\n');
                const similarNames = rows.map(row => row.u_name);
                similarNames.forEach((name, index) => {
                    terminal.cyan(`${index + 1}: ${name}\n`);
                });

                // Ask the user to select a name from the list
                terminal('Select a user by number: ');
                const selectedNumber = await new Promise(resolve => terminal.inputField((_, input) => resolve(Number(input.trim()) - 1)));

                if (selectedNumber < 0 || selectedNumber >= similarNames.length) {
                    terminal.red('Invalid selection.\n');
                    return null;
                }

                const selectedName = similarNames[selectedNumber];
                terminal.yellow(`Revoking user '${selectedName}'...\n`);

                // Attempt to revoke the selected user
                values = [selectedName];
                query = `
            UPDATE ${DBUSERTABLE}
            SET u_status = 0
            WHERE u_name = ?;
          `;
                [result] = await pool.query(query, values);

                if (result.affectedRows === 0) {
                    terminal.red(`Failed to revoke user '${selectedName}'.\n`);
                } else {
                    terminal.green(`User '${selectedName}' successfully revoked.\n`);
                }
            }
        } else {
            terminal.green(`User '${userName}' successfully revoked.\n`);
        }

        return result;
    } catch (error) {
        terminal.red(`Error revoking user: ${error.message}\n`);
        return null;
    }
}

/**
 * Restores a user by name by setting their status to active (1).
 * If the exact name is not found, performs a Soundex search to find similar names.
 *
 * @param {Object} terminal - The terminal interface.
 * @param {string} userName - The name of the user to restore.
 * @returns {Promise<void>}
 */
export async function restoreUserByName(terminal, userName) {
    try {
        // Attempt to restore user by exact name
        let query = `
        UPDATE ${DBUSERTABLE}
        SET u_status = 1
        WHERE u_name = ?;
      `;

        let values = [userName];
        let [result] = await pool.query(query, values);

        if (result.affectedRows === 0) {
            terminal.red(`No user found with the exact name '${userName}'.\n`);

            // Perform a Soundex search for similar names
            terminal.yellow('Performing a Soundex search for similar names...\n');
            query = `
          SELECT u_name
          FROM ${DBUSERTABLE}
          WHERE SOUNDEX(u_name) = SOUNDEX(?);
        `;
            const [rows] = await pool.query(query, values);

            if (rows.length === 0) {
                terminal.red('No similar names found.\n');
                waitForKeyPress(terminal);
                return null;
            } else {
                terminal.cyan('Found similar names:\n');
                const similarNames = rows.map(row => row.u_name);
                similarNames.forEach((name, index) => {
                    terminal.cyan(`${index + 1}: ${name}\n`);
                });

                // Ask the user to select a name from the list
                terminal('Select a user by number: ');
                const selectedNumber = await new Promise(resolve => terminal.inputField((_, input) => resolve(Number(input.trim()) - 1)));

                if (selectedNumber < 0 || selectedNumber >= similarNames.length) {
                    terminal.red('Invalid selection.\n');
                    return null;
                }

                const selectedName = similarNames[selectedNumber];
                terminal.yellow(`Restoring user '${selectedName}'...\n`);

                // Attempt to restore the selected user
                values = [selectedName];
                query = `
            UPDATE ${DBUSERTABLE}
            SET u_status = 1
            WHERE u_name = ?;
          `;
                [result] = await pool.query(query, values);

                if (result.affectedRows === 0) {
                    terminal.red(`Failed to restore user '${selectedName}'.\n`);
                } else {
                    terminal.green(`User '${selectedName}' successfully restored.\n`);
                }
            }
        } else {
            terminal.green(`User '${userName}' successfully restored.\n`);
        }

        return result;
    } catch (error) {
        terminal.red(`Error restoring user: ${error.message}\n`);
        return null;
    }
}

/**
 * Deletes a user by name by setting their deleted status to true (1).
 * If the exact name is not found, performs a Soundex search to find similar names.
 *
 * @param {Object} terminal - The terminal interface.
 * @param {string} userName - The name of the user to delete.
 * @returns {Promise<void>}
 */
export async function setUserDeletableByName(terminal, userName) {
    try {
        // Attempt to delete user by exact name
        let query = `
        UPDATE ${DBUSERTABLE}
        SET u_deleted_status = 1
        WHERE u_name = ?;
      `;

        let values = [userName];
        let [result] = await pool.query(query, values);

        if (result.affectedRows === 0) {
            terminal.red(`No user found with the exact name '${userName}'.\n`);

            // Perform a Soundex search for similar names
            terminal.yellow('Performing a Soundex search for similar names...\n');
            query = `
          SELECT u_name
          FROM ${DBUSERTABLE}
          WHERE SOUNDEX(u_name) = SOUNDEX(?);
        `;
            const [rows] = await pool.query(query, values);

            if (rows.length === 0) {
                terminal.red('No similar names found.\n');
                waitForKeyPress(terminal);
                return null;
            } else {
                terminal.cyan('Found similar names:\n');
                const similarNames = rows.map(row => row.u_name);
                similarNames.forEach((name, index) => {
                    terminal.cyan(`${index + 1}: ${name}\n`);
                });

                // Ask the user to select a name from the list
                terminal('Select a user by number: ');
                const selectedNumber = await new Promise(resolve => terminal.inputField((_, input) => resolve(Number(input.trim()) - 1)));

                if (selectedNumber < 0 || selectedNumber >= similarNames.length) {
                    terminal.red('Invalid selection.\n');
                    return null;
                }

                const selectedName = similarNames[selectedNumber];
                terminal.yellow(`Setting user deletable '${selectedName}'...\n`);

                // Attempt to delete the selected user
                values = [selectedName];
                query = `
            UPDATE ${DBUSERTABLE}
            SET u_deleted_status = 1
            WHERE u_name = ?;
          `;
                [result] = await pool.query(query, values);

                if (result.affectedRows === 0) {
                    terminal.red(`Failed to set user deletable '${selectedName}'.\n`);
                } else {
                    terminal.green(`User '${selectedName}' successfully set as deletable.\n`);
                }
            }
        } else {
            terminal.green(`User '${userName}' successfully set as deletable.\n`);
        }

        return result;
    } catch (error) {
        terminal.red(`Error deleting user: ${error.message}\n`);
        return null;
    }
}

/**
 * Permanently deletes a user by name from the database.
 * If the exact name is not found, performs a Soundex search to find similar names.
 *
 * @param {Object} terminal - The terminal interface.
 * @param {string} userName - The name of the user to delete.
 * @returns {Promise<void>}
 */
export async function deleteUserByName(terminal, userName) {
    try {
        // Attempt to delete user by exact name
        let query = `
        DELETE FROM ${DBUSERTABLE}
        WHERE u_name = ?;
      `;

        let values = [userName];
        let [result] = await pool.query(query, values);

        if (result.affectedRows === 0) {
            terminal.red(`No user found with the exact name '${userName}'.\n`);

            // Perform a Soundex search for similar names
            terminal.yellow('Performing a Soundex search for similar names...\n');
            query = `
          SELECT u_name
          FROM ${DBUSERTABLE}
          WHERE SOUNDEX(u_name) = SOUNDEX(?);
        `;
            const [rows] = await pool.query(query, values);

            if (rows.length === 0) {
                terminal.red('No similar names found.\n');
                waitForKeyPress(terminal);
                return null;
            } else {
                terminal.cyan('Found similar names:\n');
                const similarNames = rows.map(row => row.u_name);
                similarNames.forEach((name, index) => {
                    terminal.cyan(`${index + 1}: ${name}\n`);
                });

                // Ask the user to select a name from the list
                terminal('Select a user by number: ');
                const selectedNumber = await new Promise(resolve => terminal.inputField((_, input) => resolve(Number(input.trim()) - 1)));

                if (selectedNumber < 0 || selectedNumber >= similarNames.length) {
                    terminal.red('Invalid selection.\n');
                    return null;
                }

                const selectedName = similarNames[selectedNumber];
                terminal.yellow(`Deleting user '${selectedName}'...\n`);

                // Attempt to delete the selected user
                values = [selectedName];
                query = `
            DELETE FROM ${DBUSERTABLE}
            WHERE u_name = ?;
          `;
                [result] = await pool.query(query, values);

                if (result.affectedRows === 0) {
                    terminal.red(`Failed to delete user '${selectedName}'.\n`);
                } else {
                    terminal.green(`User '${selectedName}' successfully deleted.\n`);
                }
            }
        } else {
            terminal.green(`User '${userName}' successfully deleted.\n`);
        }

        // Reorganize the table indexes after deletion
        await pool.query(`OPTIMIZE TABLE ${DBUSERTABLE}`);
        terminal.green(`Table indexes reorganized successfully.\n`);

        return result;
    } catch (error) {
        terminal.red(`Error deleting user: ${error.message}\n`);
        return null;
    }
}

// Export the pool for use elsewhere in the application
export default pool;

